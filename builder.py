import sys, os, errno, stat
import vars, state
from helpers import unlink, close_on_exec, join
from log import log, log_, debug, debug2, err, warn


def _default_do_files(filename):
    l = filename.split('.')
    for i in range(1,len(l)+1):
        basename = join('.', l[:i])
        ext = join('.', l[i:])
        if ext: ext = '.' + ext
        yield ("default%s.do" % ext), basename, ext
    

def _possible_do_files(t):
    dirname,filename = os.path.split(t)
    yield (os.path.join(vars.BASE, dirname), "%s.do" % filename,
           '', filename, '')

    # It's important to try every possibility in a directory before resorting
    # to a parent directory.  Think about nested projects: I don't want
    # ../../default.o.do to take precedence over ../default.do, because
    # the former one might just be an artifact of someone embedding my project
    # into theirs as a subdir.  When they do, my rules should still be used
    # for building my project in *all* cases.
    t = os.path.normpath(os.path.join(vars.BASE, t))
    dirname,filename = os.path.split(t)
    dirbits = dirname.split('/')
    for i in range(len(dirbits), -1, -1):
        basedir = join('/', dirbits[:i])
        subdir = join('/', dirbits[i:])
        for dofile,basename,ext in _default_do_files(filename):
            yield (basedir, dofile,
                   subdir, os.path.join(subdir, basename), ext)
        

def _find_do_file(f):
    for dodir,dofile,basedir,basename,ext in _possible_do_files(f.name):
        dopath = os.path.join(dodir, dofile)
        debug2('%s: %s:%s ?\n' % (f.name, dodir, dofile))
        if os.path.exists(dopath):
            f.add_dep('m', dopath)
            return dodir,dofile,basedir,basename,ext
        else:
            f.add_dep('c', dopath)
    return None,None,None,None,None


def _nice(t):
    return state.relpath(t, vars.STARTDIR)


def _try_stat(filename):
    try:
        return os.stat(filename)
    except OSError, e:
        if e.errno == errno.ENOENT:
            return None
        else:
            raise


def build(t):
    tmpbase = t
    sf = state.File(name=t)
    while not os.path.isdir(os.path.dirname(tmpbase) or '.'):
        ofs = tmpbase.rfind('/')
        assert(ofs >= 0)
        tmpbase = tmpbase[:ofs] + '__' + tmpbase[ofs+1:]
    tmpname1 = '%s.redo1.tmp' % tmpbase
    tmpname2 = '%s.redo2.tmp' % tmpbase
    before_t = _try_stat(t)

    newstamp = sf.read_stamp()
    if (sf.is_generated and
        newstamp != state.STAMP_MISSING and 
        (sf.stamp != newstamp or sf.is_override)):
            state.warn_override(_nice(t))
            sf.set_override()
            sf.set_checked()
            sf.save()
            return 0
    if (os.path.exists(t) and not os.path.isdir(t + '/.')
             and not sf.is_generated):
            # an existing source file that was not generated by us.
            # This step is mentioned by djb in his notes.
            # For example, a rule called default.c.do could be used to try
            # to produce hello.c, but we don't want that to happen if
            # hello.c was created by the end user.
            # FIXME: always refuse to redo any file that was modified outside
            # of redo?  That would make it easy for someone to override a
            # file temporarily, and could be undone by deleting the file.
            debug2("-- static (%r)\n" % t)
            sf.set_static()
            sf.save()
            return 0
    sf.zap_deps1()
    (dodir, dofile, basedir, basename, ext) = _find_do_file(sf)
    if not dofile:
        if os.path.exists(t):
            sf.set_static()
            sf.save()
            return 0
        else:
            err('no rule to make %r\n' % t)
            return 1
    unlink(tmpname1)
    unlink(tmpname2)
    ffd = os.open(tmpname1, os.O_CREAT|os.O_RDWR|os.O_EXCL, 0666)
    close_on_exec(ffd, True)
    f = os.fdopen(ffd, 'w+')
    # this will run in the dofile's directory, so use only basenames here
    arg1 = basename + ext  # target name (including extension)
    arg2 = basename        # target name (without extension)
    argv = ['sh', '-e',
            dofile,
            arg1,
            arg2,
            # temp output file name
            state.relpath(os.path.abspath(tmpname2), dodir),
            ]
    firstline = open(os.path.join(dodir, dofile)).readline().strip()
    if firstline.startswith('#!/'):
        argv[0:2] = firstline[2:].split(' ')
    log('%s\n' % _nice(t))
    sf.is_generated = True
    sf.save()
    dof = state.File(name=os.path.join(dodir, dofile))
    dof.set_static()
    dof.save()
    state.commit()

    pid = os.fork()
    if pid == 0:  # child
        try:
            dn = dodir
            newp = os.path.realpath(dn)
            os.environ['REDO_PWD'] = state.relpath(newp, vars.STARTDIR)
            os.environ['REDO_TARGET'] = basename + ext
            os.environ['REDO_DEPTH'] = vars.DEPTH + '  '
            if dn:
                os.chdir(dn)
            os.dup2(f.fileno(), 1)
            os.close(f.fileno())
            close_on_exec(1, False)
            os.execvp(argv[0], argv)
        finally:
            # returns only if there's an exception
            sys._exit(127)

    # otherwise, we're the parent
    outpid = 0
    while outpid != pid:
        outpid, status = os.waitpid(pid, 0)
    if os.WIFEXITED(status):
        rv = os.WEXITSTATUS(status)
    else:
        rv = -os.WSTOPSIG(status)
    state.check_sane()

    after_t = _try_stat(t)
    st1 = os.fstat(f.fileno())
    st2 = _try_stat(tmpname2)
    if (after_t and 
        (not before_t or before_t.st_ctime != after_t.st_ctime) and
        not stat.S_ISDIR(after_t.st_mode)):
            err('%s modified %s directly!\n' % (argv[2], t))
            err('...you should update $3 (a temp file) or stdout, not $1.\n')
            rv = 206
    elif st2 and st1.st_size > 0:
        err('%s wrote to stdout *and* created $3.\n' % argv[2])
        err('...you should write status messages to stderr, not stdout.\n')
        rv = 207
    if rv==0:
        if st2:
            os.rename(tmpname2, t)
            os.unlink(tmpname1)
        elif st1.st_size > 0:
            try:
                os.rename(tmpname1, t)
            except OSError, e:
                if e.errno == errno.ENOENT:
                    unlink(t)
                else:
                    raise
        else: # no output generated at all; that's ok
            unlink(tmpname1)
            unlink(t)
        sf.refresh()
        sf.is_generated = True
        sf.is_override = False
        if sf.is_checked() or sf.is_changed():
            # it got checked during the run; someone ran redo-stamp.
            # update_stamp would call set_changed(); we don't want that
            sf.stamp = sf.read_stamp()
        else:
            sf.csum = None
            sf.update_stamp()
            sf.set_changed()
    else:
        unlink(tmpname1)
        unlink(tmpname2)
        sf = sf
        sf.set_failed()
    sf.zap_deps2()
    sf.save()
    f.close()
    if rv != 0:
        err('%s: exit code %d\n' % (_nice(t),rv))
    
    state.commit()
    return rv


def main(targets, shouldbuildfunc):
    try:
        for t in targets:
            dirty = shouldbuildfunc(t)
            if dirty and dirty != True:
                for t2 in dirty:
                    t2path = state.relpath(os.path.join(vars.BASE, t2.name),
                                           os.getcwd())
                    rv = build(t2path)
                    if rv:
                        return rv
            dirty = shouldbuildfunc(t)
            if dirty:
                rv = build(t)
                if rv:
                    return rv
    finally:
        state.commit()
